var fs = require('fs');

// base class for Gopherwatch League spreadsheet
module.exports = class GWLSpreadsheet {
	name; // name of the season
	internal; // internal name used
	ongoing; // whether the tournament is ongoing
	spreadsheetId; // the spreadsheet's id (string after the last '/' in url)
	teams; // the teams in the tournament
	teamPageTemplatePath; // the path to the teampage HTML template, constant to subclass
	format; // the format of the tournament
	className; // the name of the class
	meta; // metadata info object (i.e. meta.hasStats = true)
	currentRound; // the current round, used to show current week in 
	
	// creates a spreadsheet
	constructor(name, internal, ongoing, spreadsheetId) {
		this.name = name;
		this.internal = internal;
		this.ongoing = ongoing;
		this.spreadsheetId = spreadsheetId;
		this.format = "unformatted";
		this.className = "GWLSpreadsheet";
		this.teams = [];
		this.meta = {};
		
		this.teamPageTemplatePath = "/client/Teams/team.html";
	}
	
	// builds the directory structure
	buildDirectory() {
		console.info('Using default buildDirectory, but it is best practice to override');
		return new Promise((resolve,reject) => {
			fs.mkdirSync("./data/" + this.internal);
			fs.mkdirSync("./data/" + this.internal + "/teams");
			
			// don't cache if this is an ongoing tournament
			if(this.ongoing) {
				fs.copyFileSync('./gitignore_template', './data/' + this.internal + '/.gitignore');
				fs.copyFileSync('./gitignore_template', './data/' + this.internal + '/teams/.gitignore');
			}
			resolve(null);
		});
	}
	
	// generates a link dictionary
	generateLinkDict() {
		console.log("Generating dict for " + this.name);
		return new Promise((resolve,reject) => {	
			// get players
			this.getPlayers()
			.then(playersJson => {
				let dict = {
					players : [],
					teams : []
				};
				let players = playersJson.players;
				
				for(let j=0;j<players.length;++j) {
					if(!players[j].battletag) reject(`Error linking player: sheet name "${this.name}, player index ${j}`);
					
					let w = players[j].battletag;
					let l = `/${this.internal}/Player/${w.replace('#','-')}`;
					let entry = { word: w, link: l };
					dict.players.push(entry);
				}
				
				for(i=0;i<this.teams.length;++i) {
					if(!this.teams[i].name || !this.teams[i].internal) reject(`Error linking team: sheet name "${this.name}", teams index ${i}`);
					
					let w = this.teams[i].name;
					let l = "/" + this.internal + "/Teams/" + this.teams[i].internal;
					let entry = { word: w, link: l };
					dict.teams.push(entry);
				}
				console.log("Dict completed for " + this.name);
				this.storeLinkDict(dict)
				.then(resolve(dict))
				.catch(err => {
					console.log("Storing dict fucked up! err=" + err);
					reject(err);
				});
			})
			.catch(err => reject(err));
		});
	}
	
	// loads a serialized object into the class
	static loadObject(obj) {
		return new Promise((resolve,reject) => {
			// check it is the correct format
			if(obj.format != "unformatted") {
				console.log("Object is not a GWLSpreadsheet object!");
				reject("InvalidFormat");
			}
			var sheet = new GWLSpreadsheet(obj.name, obj.internal, obj.ongoing, obj.spreadsheetId);
			resolve(sheet);
		});
	}
	
	// abstract method to access spreadsheet info (typically stored in Info tab)
	loadSheetInfo() {
		return new Promise((resolve,reject) => {
			reject('You have not implemented the method loadSheetInfo!');
		});
	}
	
	// abstract method to BatchGet all info
	batchGetAll() {
		return new Promise((resolve,reject) => {
			reject('You have not implemented the method batchGetAll!');
		});
	}
	
	// abstract method to store link dictionary
	storeLinkDict(dict) {
		return new Promise((resolve,reject) => {
			reject('You have not implemented the method storeLinkDict!');
		});
	}
	
	// abstract method to get link dictionary
	getLinkDict() {
		return new Promise((resolve,reject) => {
			reject('You have not implemented the method getLinkDict!');
		});
	}
	
	// abstract method to get player info
	getPlayerInfo(battletag) {
		return new Promise((resolve,reject) => {
			reject('You have not implemented the method getPlayerInfo!');
		});
	}
	
	getPlayers() {
		return new Promise((resolve,reject) => {
			reject('You have not implemented the method getPlayers!');
		});
	}
	
	getStandings() {
		return new Promise((resolve,reject) => {
			reject('You have not implemented the method getStandings!');
		});
	}
	
	// abstract method to get team info
	getTeamInfo(team) {
		console.info('Using default getTeamInfo, but it is best practice to override!');
		return new Promise((resolve,reject) => {
			localfs.openJsonPromise("./data/" + this.internal + "/teams/" + team + ".json")
			.then(data => resolve(data))
			.catch(err => reject(err))
		});
	}
	
	getMatches() {
		return new Promise((resolve,reject) => {
			reject('You have not implemented the method getMatches!');
		});
	}
}