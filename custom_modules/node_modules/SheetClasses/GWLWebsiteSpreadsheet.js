var GWLSpreadsheet = require('@sheets/GWLSpreadsheet');
var googleAuth = require('@mymodules/auth');
const localfs = require('@mymodules/localfs');
const sanitize = require('@mymodules/utils').sanitize;
var {google} = require('googleapis');
var sheetsApi = google.sheets('v4');
const utils = require('@mymodules/utils');

// spreadsheet id
const WEBSITE_SHEET_ID = '19HBfEIuWOvJU0agDNRP1gSKEzjraIX4AxDLniSj4Uks';

module.exports = class GWLWebsiteSpreadsheet extends GWLSpreadsheet {
	
	// initializes an instance of this class, override the format, class name, 
	// teampage path, and anything else
	constructor() {
		super('Website Sheet', 'WebsiteSheet', false, WEBSITE_SHEET_ID);
		
		// Change these!
		this.format = "WebsiteSheet";
		this.className = "GWLWebsiteSpreadsheet";
		this.teamPageTemplatePath = "/client/404.html";
	}
	
	// loads a serialized object into the class
	// returns a promise that resolves the object when it is loaded, and
	// rejects if the sheet is not formatted correctly
	// don't forget to import into spreadsheetTypes.js and update loadSheet()!!!!!
	static loadObject(obj) {
		return new Promise((resolve,reject) => {
			var sheet = new GWLWebsiteSpreadsheet();
			resolve(sheet);
		});
	}
	
	// builds the directory structure in ./data/[internal]
	// returns promise that resolves when local directory is complete and
	// rejects if there is an fs error.
	// by default creates a ./data/[internal] and ./data/[internal]/teams directory, but can be overridden
	buildDirectory() {
		return new Promise((resolve,reject) => {
			fs.mkdirSync("./data/" + this.internal);
			
			resolve(null);
		});
	}
	
	// called by build function to get season info from the sheet's Info tab
	// this loads metadata required to handle the season's info, such as team names
	loadSheetInfo() {
		return Promise.resolve();
	}
	
	// stores a computed link dictionary
	storeLinkDict(dict) {
		return new Promise((resolve,reject) => {
			console.log("There is no linkdict smile");
			resolve("oop");
		});
	}
	
	// retrieves the link dictionary, see above
	getLinkDict() {
		return new Promise((resolve,reject) => {
			console.log("there is no linkdict :)");
			resolve("ope");
		});
	}
	
	// runs a BatchGet Google API request and stores the results in whatever
	// local file format the sheet uses. This is where most of the work is done. 
	batchGetAll() {
		return new Promise((resolve,reject) => {
			console.error("Website spreadsheet does not use BatchGet!");
			reject("argh!");
		});
	}
	
	// ====== Put private functions used in data storage below! ======== 
	
	// convert an info array of objects into a data request the API can use
	_playerInfoToRequest(infoArr) {
		let req = {
			majorDimension: "ROWS",
			values: []
		}
		
		// fill in values
		infoArr.forEach(player => {
			let row = [
				player.battletag,
				player.teams,
				player.tank,
				player.tankLastUpdated,
				player.dps,
				player.dpsLastUpdated,
				player.support,
				player.supportLastUpdated,
				player.realname,
				player.playernumber,
				player.pronouns,
				player.hometown,
				player.major,
				player.twitch,
				player.twitter,
				player.youtube,
				player.instagram,
				player.reddit,
				player.role,
				player.hero,
				player.picture,
				player.bio,
				player.mvp
			];
			req.values.push(row);
		});
		
		// fill in the rest of the region with empty strings (important if player list size decreases)
		let blankRows = 998 - req.values.length; // update 9998 if size of sheet changes! should last a long time though w ~160 players = ~50ish joining per year
		var emptyRow = [];
		for(let rowLength = 0; rowLength < 23; ++rowLength) emptyRow.push('');
		for(i=0; i<blankRows; ++i) {
			req.values.push(emptyRow);
		}
		
		// sanity check for arr size
		if(req.values.length != 998) {
			console.error("Req values has an invalid length! req.values.count=" + req.values.length);
		}
		
		return req;
	}
	
	
	
	// Following functions just grab files from the right part of the 
	// data structure defined earlier

	// promise gets the players.json file and returns it
	getPlayers() {
		return new Promise((resolve,reject) => {
			localfs.openJsonPromise('./data/player_info.json')
			.then(res => resolve(res))
			.catch(err => reject(err));
		});
	}
	
	// Stores a given player info set in the sheet
	storePlayerInfo(infoArr) {
		return new Promise((resolve,reject) => {
			
			// generate ranges
			let ranges = 'MergedSeasonData!A3:W1000';
			
			// convert info array to request body
			let resource = this._playerInfoToRequest(infoArr);
			
			// get data on all ranges
			googleAuth.authorize()
			.then((auth) => {
				sheetsApi.spreadsheets.values.update({
					auth: auth,
					spreadsheetId: this.spreadsheetId,
					range: ranges,
					valueInputOption: 'RAW',
					resource: resource
				}, (err, response) => {
					if (err) {
						console.log('The API returned an error: ' + err);
						reject(err);
					}
					//localfs.writeJsonPromise('./'+this.internal+'.json',response)
					utils.printMessage("Stored player info for website sheet!", "success")
					.then(res => resolve(res))
					.catch(err => reject(err));
				});
			})
			.catch((err) => {
				reject(err);
			});
		});
	}
	
	// same as getPlayers but returns a specific player.
	getPlayerInfo(battletag) {
		return new Promise((resolve,reject) => {
			// TODO promise for players file
			this.getPlayers()
			.then(res => utils.getPlayerFromObj(res, battletag))
			.then(res2 => resolve(res2))
			.catch(err => reject(err));
		});
	}
	
	// promise gets the standings file and returns it 
	getStandings() {
		return new Promise((resolve,reject) => {
			// TODO return standings file
		});
	}
	
	// promise gets team's info and returns it
	getTeamInfo(team) {
		return new Promise((resolve,reject) => {
			// TODO return team's file
		});
	}
	
	// promise gets the match log and returns it
	getMatches() {
		return new Promise((resolve,reject) => {
			// TODO get match log
		});
	}
	
	// promise gets the hero stats and returns it
	getHeroStats() {
		return new Promise((resolve,reject) => {
			// TODO get hero stats file
		});
	}
}