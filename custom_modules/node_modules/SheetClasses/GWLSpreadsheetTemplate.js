var GWLSpreadsheet = require('@sheets/GWLSpreadsheet');
var googleAuth = require('@mymodules/auth');
const localfs = require('@mymodules/localfs');
const sanitize = require('@mymodules/utils').sanitize;
var {google} = require('googleapis');
var sheetsApi = google.sheets('v4');

// =======================
// How to add a sheet:
//
// 1. Duplicate this class, go through and add code where comments tell unless
// 2. Go to spreadsheet-types.js and add a require() for it, then add code to
//    loadSheet() that checks for the format and adds it. 
// =======================

// TODO name class
module.exports = class GWLSpreadsheetTemplate extends GWLSpreadsheet {
	// initializes an instance of this class, override the format, class name, 
	// teampage path, and anything else
	constructor(name, internal, ongoing, spreadsheetId) {
		super(name, internal, ongoing, spreadsheetId);
		
		// Change these!
		this.format = "format";
		this.className = "GWLSpreadsheetTemplate";
		this.teamPageTemplatePath = "/client/404.html";
	}
	
	// loads a serialized object into the class
	// returns a promise that resolves the object when it is loaded, and
	// rejects if the sheet is not formatted correctly
	// don't forget to import into spreadsheetTypes.js and update loadSheet()!!!!!
	static loadObject(obj) {
		return new Promise((resolve,reject) => {
			if(obj.format != "generaldata") {
				console.log("Object is not a GWLWebsiteSpreadsheet object!");
				reject("InvalidFormat");
			}
			var sheet = new GWLWebsiteSpreadsheet(obj.spreadsheetId);
			resolve(sheet);
		});
	}
	
	// builds the directory structure in ./data/[internal]
	// returns promise that resolves when local directory is complete and
	// rejects if there is an fs error.
	// by default creates a ./data/[internal] and ./data/[internal]/teams directory, but can be overridden
	buildDirectory() {
		return super.buildDirectory();
	}
	
	// called by build function to get season info from the sheet's Info tab
	// this loads metadata required to handle the season's info, such as team names
	loadSheetInfo() {
		return new Promise((resolve,reject) => {
			googleAuth.authorize()
			.then((auth) => {
				sheetsApi.spreadsheets.values.batchGet({
					auth: auth,
					spreadsheetId: this.spreadsheetId,
					ranges: [
						// TODO add ranges
					]
				}, (err, response) => {
					if(err) {
						console.log("Google API returned an error: " + err);
						reject(err);
					}
					
					// TODO store info from request
				});
				
				// batch get completed and results stored, we can resolve now
				resolve(this);
			})
			.catch((err) => {
				// called when authorize() fails
				console.error('Authentication error: ', err);
				reject(err);
			});
		});
	}
	
	// stores a computed link dictionary
	storeLinkDict(dict) {
		return new Promise((resolve,reject) => {
			// store the dictionary
			// the path can be changed but you should also update the getLinkDict function below
			localfs.writeJsonPromise(`./data/${this.internal}/linkdict.json`, dict)
			.then(() => resolve("Success!"))
			.catch(err => {
				console.log("Error storing dictionary for sheet ", this.internal);
				reject(err);
			});
		});
	}
	
	// retrieves the link dictionary, see above
	getLinkDict() {
		return new Promise((resolve,reject) => {
			localfs.openJsonPromise(`./data/${this.internal}/linkdict.json`)
			.then(obj => resolve(obj))
			.catch(err => reject(err)); // should not happen unless someone manually entered an invalid dictionary
		});
	}
	
	// runs a BatchGet Google API request and stores the results in whatever
	// local file format the sheet uses. This is where most of the work is done. 
	batchGetAll() {
		return new Promise((resolve,reject) => {
			// build ranges
			let ranges = [];
			//ranges.push('Sheet!A1:D20');
			
			// push request for these ranges
			googleAuth.authorize()
			.then((auth) => {
				sheetsApi.spreadsheets.values.batchGet({
					auth: auth,
					spreadsheetId: this.spreadsheetId,
					ranges: ranges
				}, (err, response) => {
					// handle error
					if(err) {
						console.error('sheetsApi.batchGet returned an error: ', err);
						console.error(err.stack);
						reject(err);
					}
					
					// handle the data returned
					// not strictly required but I recommend handling in a separate storeBatchGet function
					this.storeBatchGet(response.data)
					// don't forget to resolve!
					.then(res => resolve(res))
					.catch(err => reject(err));
				});
			})
			.catch((err) => {
				// called when authorize() fails
				console.error('Authentication error: ', err);
				reject(err);
			});
		});
	}
	
	// stores data captured by batchGetAll
	// again, not strictly necessary but helps avoid callback hell
	storeBatchGet(data) {
		return new Promise((resolve,reject) => {
			// highly recommend to make separate private functions for these as well,
			// using either a promise chain or a Promise.all()
			
			// TODO store the current round
			// TODO store the match log
			// TODO store hero stats
			// TODO store standings
			// TODO store player info
			// TODO store team pages
		});
	}
	
	// ====== Put private functions used in data storage below! ======== 
	
	
	
	
	
	// Following functions just grab files from the right part of the 
	// data structure defined earlier

	// promise gets the players.json file and returns it
	getPlayers() {
		return new Promise((resolve,reject) => {
			// TODO return players file
		});
	}
	
	// same as getPlayers but returns a specific player.
	getPlayerInfo(battletag) {
		return new Promise((resolve,reject) => {
			// TODO promise for players file
			.then(res => dh.getPlayerFromJson(res, battletag))
			.then(res2 => resolve(res2))
			.catch(err => reject(err));
		});
	}
	
	// promise gets the standings file and returns it 
	getStandings() {
		return new Promise((resolve,reject) => {
			// TODO return standings file
		});
	}
	
	// promise gets team's info and returns it
	getTeamInfo(team) {
		return new Promise((resolve,reject) => {
			// TODO return team's file
		});
	}
	
	// promise gets the match log and returns it
	getMatches() {
		return new Promise((resolve,reject) => {
			// TODO get match log
		});
	}
	
	// promise gets the hero stats and returns it
	getHeroStats() {
		return new Promise((resolve,reject) => {
			// TODO get hero stats file
		});
	}
}